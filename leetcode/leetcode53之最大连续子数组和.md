---
title: leetcode53之最大连续子数组和 
tags: leetcode,算法, C++
grammar_cjkRuby: true
---
## 题目
- 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
- 输入: [-2,1,-3,4,-1,2,1,-5,4]；输出: 6；解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
- 尽量实现复杂度为O(n)的算法，还可以采用分治的方法。
## 分析
- 这道题第一个想法是直接暴力求解。三重循环，但是时间复杂度太高了。
- 分治的方法在算法导论上面做过，将数组分成两个部分，分别求出最大子数组和，然后还要处理一种横跨两个子数组的连续数组和，比较三者之间的最大值。分治的方法写起来比较麻烦。
- 参考网上的解答，可以利用动态规划。关键是如何定义状态。这道题可以定义以第i个数字作为结尾的最大子数组和为dp[i]，那么以i+1个数字作为结尾的最大子数组和就可以由状态转移方程获得。
- 还有一种方法是记录当前的连续数组和，根据其大小即是否小于0。如果大于0，证明以后一个数字开头的子数组加上前面的连续子数组会更大，所以应该继续叠加。如果小于0，则重新开始计算连续子数组的值。始终保持一个记录扫描过的子数组的最大值的变量。最后返回变脸即可。
## 代码
采用的是第三种方法，时间复杂读为O(n)。
```c++?linenums
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        // 分析遍历数组的情况。维持一个连续的数组元素和。
        // 如果该数组的和大于0,那么加上一个元素之后的值肯定大于这个元素的值。
        // 也就是说，从后一个元素开始的子数组和加上前面的数组会更大。
        // 但是，如果当前的数组和是负数，加上后肯定没有从后一个元素开始的子数组的和大。
        int max = nums[0];
        int sum = nums[0];
        for(int i = 1; i < nums.size(); i++){
            if(sum < 0){
                sum = nums[i];
            }
            else{
                
                sum += nums[i];
            }   
            if(sum > max){
                    max = sum;
                }
        }
        return max;
    }
};
```
## 总结
动态规划需要拆分求解的问题，分阶段求解，然后保留中间值。